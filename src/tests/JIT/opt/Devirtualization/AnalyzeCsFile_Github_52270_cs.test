// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System.Diagnostics;
using System.Runtime.InteropServices;

// NOTE: this file is just a test data for AnalyzeCsFile_Github_52270 runtime test

namespace System.Text
{
    public abstract class Decoder3
    {
        internal DecoderFallback3? _fallback;
        internal DecoderFallbackBuffer3? _fallbackBuffer;
        public DecoderFallback3? Fallback
        {
            get => _fallback;
            set
            {
                if (value == null)
                    throw new ArgumentNullException(nameof(value));
                if (_fallbackBuffer != null && _fallbackBuffer.Remaining > 0)
                    throw new ArgumentException(
                      SR.Axrgument_FallbackBufferNotEmpty, nameof(value));
                _fallback = value;
                _fallbackBuffer = null;
            }
        }
        public DecoderFallbackBuffer3 FallbackBuffer
        {
            get
            {
                if (_fallbackBuffer == null)
                {
                    if (_fallback != null)
                        _fallbackBuffer = _fallback.CreateFallbackBuffer();
                    else
                        _fallbackBuffer = DecoderFallback.ReplacementFallback.CreateFallbackBuffer();
                }
                return _fallbackBuffer;
            }
        }
        public virtual unsafe int GetCharCount(byte* bytes, int count, bool flush)
        {
            if (bytes == null)
                throw new ArgumentNullException(nameof(bytes),SR.AxrgumentNull_Array);
            if (count < 0)
                throw new ArgumentOutOfRangeException(nameof(count),SR.AxrgumentOutOfRange_NeedNonNegNum);
            byte[] arrbyte = new byte[count];
            int index;
            for (index = 0; index < count; index++)
                arrbyte[index] = bytes[index];
            return GetCharCount(arrbyte, 0, count);
        }
        public virtual unsafe int GetChars(byte* bytes, int byteCount,
                                              char* chars, int charCount, bool flush)
        {
            if (chars == null || bytes == null)
                throw new ArgumentNullException(chars == null ? nameof(chars) : nameof(bytes),
                    SR.AxrgumentNull_Array);
            if (byteCount < 0 || charCount < 0)
                throw new ArgumentOutOfRangeException(byteCount < 0 ? nameof(byteCount) : nameof(charCount),
                    SR.AxrgumentOutOfRange_NeedNonNegNum);
            byte[] arrByte = new byte[byteCount];
            int index;
            for (index = 0; index < byteCount; index++)
                arrByte[index] = bytes[index];
            char[] arrChar = new char[charCount];
            int result = GetChars(arrByte, 0, byteCount, arrChar, 0, flush);
            Debug.Assert(result <= charCount, "Returned more chars than we have space for");
            if (result < charCount)
                charCount = result;
            for (index = 0; index < charCount; index++)
                chars[index] = arrChar[index];
            return charCount;
        }
    }
}
